{
    "schema": "conf/plugin/polardb_pg/schema.json",
    "type": "perf",
     "business":"perf",
    "context":{
    "base_path": "/flash/polardb_ppas/",
    "username": "aurora",
    "password": "",
    "database": "polardb_admin",
    "application_name":"logagent",
    "cycle": 1,
    "dbtype": "polardb_pg",
    "is_on_ecs": false,
    "queries": [
        {"query":"SELECT COUNT(*) AS connections, SUM(CASE WHEN state IN ('active') THEN 1 ELSE 0 END) AS active_connections, SUM(CASE WHEN state IN ('active') THEN 1 ELSE 0 END) AS active_transactions, SUM(CASE WHEN wait_event != NULL THEN 1 ELSE 0 END) AS waiting_connections, SUM(CASE WHEN wait_event != NULL THEN 1 ELSE 0 END) AS waiting_transactions, SUM(CASE WHEN state IN ('idle') THEN 1 ELSE 0 END) AS idle_connections, SUM(CASE WHEN state IN ('idle in transaction', 'idle in transaction (aborted)') THEN 1 ELSE 0 END) AS idle_transactions, SUM(CASE WHEN state IN ('active') AND (now() - query_start > '10s'::interval) THEN 1 ELSE 0 END) AS long_executing_sqls, SUM(CASE WHEN state IN ('active') AND (now() - query_start > '1s'::interval) THEN 1 ELSE 0 END) AS one_second_executing_sqls, SUM(CASE WHEN state IN ('active') AND (now() - query_start > '3s'::interval) THEN 1 ELSE 0 END) AS three_seconds_executing_sqls, SUM(CASE WHEN state IN ('active') AND (now() - query_start > '5s'::interval) THEN 1 ELSE 0 END) AS five_seconds_executing_sqls, SUM(CASE WHEN state IN ('idle in transaction') AND (now() - query_start > '7200s'::interval) THEN 1 ELSE 0 END) AS long_idle_transactions, SUM(CASE WHEN state IN ('idle in transaction', 'idle in transaction (aborted)') AND (now() - state_change > '1s'::interval) THEN 1 ELSE 0 END) AS one_second_idle_transactions, SUM(CASE WHEN state IN ('idle in transaction', 'idle in transaction (aborted)') AND (now() - state_change > '3s'::interval) THEN 1 ELSE 0 END) AS three_seconds_idle_transactions, SUM(CASE WHEN state IN ('idle in transaction', 'idle in transaction (aborted)') AND (now() - state_change > '5s'::interval) THEN 1 ELSE 0 END) AS five_seconds_idle_transactions, SUM(CASE WHEN (now() - xact_start > '7200s'::interval) THEN 1 ELSE 0 END) AS long_transactions, SUM(CASE WHEN (now() - xact_start > '1s'::interval) THEN 1 ELSE 0 END) AS one_second_transactions, SUM(CASE WHEN (now() - xact_start > '3s'::interval) THEN 1 ELSE 0 END) AS three_seconds_transactions, SUM(CASE WHEN (now() - xact_start > '5s'::interval) THEN 1 ELSE 0 END) AS five_seconds_long_transactions FROM pg_stat_activity WHERE backend_type = 'client backend' AND application_name NOT IN ('logagent', 'ClusterManager')"},
        {"query":"SELECT COUNT(*) AS two_pc_transactions, SUM(CASE WHEN (now() - prepared > '7200s'::interval) THEN 1 ELSE 0 END) AS long_two_pc_transactions, SUM(CASE WHEN (now() - prepared > '1s'::interval) THEN 1 ELSE 0 END) AS one_second_two_pc_transactions, SUM(CASE WHEN (now() - prepared > '3s'::interval) THEN 1 ELSE 0 END) AS three_seconds_two_pc_transactions, SUM(CASE WHEN (now() - prepared > '5s'::interval) THEN 1 ELSE 0 END) AS five_seconds_two_pc_transactions FROM pg_prepared_xacts"},
        {"enable": 0, "query":"SELECT SUM(calls) AS calls_delta, SUM(shared_blks_hit) AS shared_blks_hit_delta, SUM(shared_blks_read) AS shared_blks_read_delta, SUM(shared_blks_dirtied) AS shared_blks_dirtied_delta, SUM(shared_blks_written) AS shared_blks_written_delta, SUM(local_blks_hit) AS local_blks_hit_delta, SUM(local_blks_read) AS local_blks_read_delta, SUM(local_blks_dirtied) AS local_blks_dirtied_delta, SUM(local_blks_written) AS local_blks_written_delta, SUM(temp_blks_read) AS temp_blks_read_delta, SUM(temp_blks_written) AS temp_blks_written_delta, SUM(stddev_time)::BIGINT AS stddev_time_delta, SUM(blk_read_time)::BIGINT AS blk_read_time_delta, SUM(blk_write_time)::BIGINT AS blk_write_time_delta FROM pg_stat_statements"},
        {"query":"SELECT SUM(numbackends) AS numbackends ,SUM(tup_returned) AS tup_returned_delta, SUM(tup_fetched) AS tup_fetched_delta, SUM(tup_inserted) AS tup_inserted_delta, SUM(tup_updated) AS tup_updated_delta, SUM(tup_deleted) AS tup_deleted_delta, SUM(xact_commit) AS commits_delta, SUM(xact_rollback) AS rollbacks_delta, SUM(deadlocks) AS deadlocks_delta, SUM(temp_files) AS temp_files_delta, SUM(temp_bytes) AS temp_bytes_delta, SUM(blks_read) AS blks_read_delta, SUM(blks_hit) AS blks_hit_delta ,SUM(conflicts) AS conflicts_delta FROM pg_stat_database"},
        {"query":"SELECT checkpoints_timed AS checkpoints_timed_delta ,checkpoints_req AS checkpoints_req_delta ,CAST(checkpoint_sync_time AS BIGINT) AS checkpoint_sync_time_delta ,CAST(checkpoint_write_time AS BIGINT) AS checkpoint_write_time_delta ,buffers_checkpoint AS buffers_checkpoint_delta ,buffers_clean AS buffers_clean_delta ,maxwritten_clean AS maxwritten_clean_delta ,buffers_backend AS buffers_backend_delta ,buffers_backend_fsync AS buffers_backend_fsync_delta ,buffers_alloc AS buffers_alloc_delta FROM pg_stat_bgwriter"},
        {"query":"WITH a AS (SELECT MIN(xact_start) m FROM pg_stat_activity WHERE backend_xid IS NOT NULL OR backend_xmin IS NOT NULL), b AS (SELECT MIN(prepared) m FROM pg_prepared_xacts) SELECT EXTRACT(EPOCH FROM NOW()-LEAST(a.m,b.m))::BIGINT AS swell_time FROM a,b",
         "cycle": 10},
        {"enable": 0, "query":"SELECT SUM(archived_count) AS archived_counts ,SUM(failed_count) AS archived_failed_counts FROM pg_stat_archiver",
         "cycle": 10},
        {"query":"SELECT MAX(AGE(datfrozenxid)) AS db_age FROM pg_database ORDER BY db_age DESC LIMIT 1",
         "cycle": 10},
        {"query":"SELECT AGE(relfrozenxid) AS table_age FROM pg_class t2 JOIN pg_namespace t3 ON t2.relnamespace = t3.oid WHERE t2.relkind IN($$t$$, $$r$$) AND t2.relname LIKE 't_%' ORDER BY age(relfrozenxid) DESC LIMIT 1",
         "cycle": 10},
        {"enable": 0, "query":"SELECT CASE WHEN( SUBSTRING( reloptions :: TEXT, $$autovacuum_freeze_max_age =(\\ d +) $$ ) :: int8 ) IS NOT NULL THEN ( SUBSTRING( reloptions :: TEXT, $$autovacuum_freeze_max_age =(\\ d +) $$ ) :: int8 ) - age(relfrozenxid) ELSE ( SELECT setting FROM pg_settings WHERE NAME = $$autovacuum_freeze_max_age$$ ) :: int8 - age(relfrozenxid) END AS table_age_remain FROM pg_class t2 JOIN pg_namespace t3 ON t2.relnamespace = t3.oid WHERE t2.relkind IN($$t$$, $$r$$) AND t2.relname LIKE 't_%' ORDER BY table_age_remain LIMIT 1",
         "cycle": 10},
        {"enable": 1, "query":"SELECT MAX(CAST(pg_wal_lsn_diff(A .c1, replay_lsn) /(1024 * 1024) AS BIGINT)) AS replay_latency_in_mb, MAX(CAST(pg_wal_lsn_diff(A .c1, sent_lsn) /(1024 * 1024) AS BIGINT)) AS send_latency_in_mb FROM pg_stat_replication, pg_current_wal_lsn() AS A(c1) WHERE usename='replicator' ORDER BY replay_latency_in_mb, send_latency_in_mb DESC LIMIT 1",
         "cycle": 10, "role": 1},
        {"enable": 1, "query":"SELECT CAST(pg_wal_lsn_diff(l.current_location, s.restart_lsn ) /(1024 * 1024) AS BIGINT) AS logical_rep_latency_in_mb FROM pg_replication_slots s, pg_current_wal_lsn() l(current_location) ORDER BY logical_rep_latency_in_mb DESC LIMIT 1",
         "cycle": 10, "role": 1},
        {"query":"SELECT CAST(pg_wal_lsn_diff(pg_current_wal_lsn(), polar_oldest_apply_lsn()) /(1024 * 1024) AS BIGINT) AS wp_ap_latency_mb, CAST(pg_wal_lsn_diff(polar_oldest_apply_lsn(), polar_consistent_lsn()) / (1024 * 1024) AS BIGINT) AS ap_cp_latency_mb, CAST(pg_wal_lsn_diff(pg_current_wal_insert_lsn(), polar_consistent_lsn()) / (1024 * 1024) AS BIGINT) AS wp_cp_latency_mb",
         "cycle": 10, "role": 1},
        {"enable": 1, "query":"SELECT CAST(polar_replica_use_xlog_queue() AS INT) AS local_iops_read, polar_used_logindex_mem_tbl_size() AS local_iops_write, CAST(pg_wal_lsn_diff(receive_lsn, pg_last_wal_replay_lsn())/(1024*1024) AS BIGINT) AS local_throughput, CAST(pg_wal_lsn_diff(receive_lsn, polar_replica_bg_replay_lsn())/(1024*1024) AS BIGINT) as local_throughput_read, CAST(pg_wal_lsn_diff(receive_lsn, polar_replica_min_used_lsn())/(1024*1024) AS BIGINT) AS local_throughput_write from (select pg_last_wal_receive_lsn() as receive_lsn) as last_wal_receive_lsn",
         "cycle": 10, "polar_release_date": 20190830},
        {"enable": 1, "query":"SELECT CAST(polar_replica_use_xlog_queue() AS INT) AS use_xlog_queue, polar_used_logindex_mem_tbl_size() AS logindex_mem_tbl_size, CAST(pg_wal_lsn_diff(receive_lsn, pg_last_wal_replay_lsn())/(1024*1024) AS BIGINT) AS replay_lag, CAST(pg_wal_lsn_diff(receive_lsn, polar_replica_bg_replay_lsn())/(1024*1024) AS BIGINT) as bg_replay_lag, CAST(pg_wal_lsn_diff(receive_lsn, polar_replica_min_used_lsn())/(1024*1024) AS BIGINT) AS min_used_lag from (select pg_last_wal_receive_lsn() as receive_lsn) as last_wal_receive_lsn",
         "cycle": 10, "polar_release_date": 20190830},
        {"query":"SELECT size AS polar_dirtypage_size FROM polar_flushlist()",
         "cycle": 10, "role": 1},
        {"query":"SELECT (copy - release) AS polar_copybuffer_used_size, \"full\"::int AS polar_copybuffer_isfull FROM polar_cbuf()",
         "cycle": 10, "role": 1},
        {"query":"SELECT polar_page_hashtable_used_size() AS polar_hashtable_used_size, polar_page_hashtable_full()::int AS polar_hashtable_isfull",
         "cycle": 10, "role": 2},
        {"query":"SELECT polar_xlog_buffer_full()::int AS polar_xlogbuffer_isfull",
         "cycle": 10, "role": 2},
        {"query":"SELECT SUM(CASE WHEN mem_type='total' THEN malloc_bytes ELSE 0 END) AS total_vfs_mem, SUM(CASE WHEN mem_type='available' THEN malloc_bytes ELSE 0 END) AS available_vfs_mem FROM polar_vfs_mem_status() WHERE mem_type IN ('total', 'available')",
         "cycle": 10},
        {"enable": 0, "query":"SELECT CASE WHEN pg_last_wal_receive_lsn() = pg_last_wal_replay_lsn() THEN 0 ELSE EXTRACT (EPOCH FROM last_msg_receipt_time - pg_last_xact_replay_timestamp()) END AS log_delay from pg_stat_wal_receiver", "role": 2},
        {"enable": 0, "query":"SELECT COUNT(*) as lock_waiting_count FROM ( WITH t_wait AS( SELECT A . MODE, A .locktype, A . DATABASE, A .relation, A .page, A .tuple, A .classid, A . GRANTED, A .objid, A .objsubid, A .pid, A .virtualtransaction, A .virtualxid, A .transactionid, A .fastpath, b. STATE, b.query, b.xact_start, b.query_start, b.usename, b.datname, b.client_addr, b.client_port, b.application_name FROM pg_locks A, pg_stat_activity b WHERE A .pid = b.pid AND NOT A . GRANTED), t_run AS( SELECT A . MODE, A .locktype, A . DATABASE, A .relation, A .page, A .tuple, A .classid, A . GRANTED, A .objid, A .objsubid, A .pid, A .virtualtransaction, A .virtualxid, A .transactionid, A .fastpath, b. STATE, b.query, b.xact_start, b.query_start, b.usename, b.datname, b.client_addr, b.client_port, b.application_name FROM pg_locks A, pg_stat_activity b WHERE A .pid = b.pid AND A . GRANTED), t_overlap AS( SELECT r.* FROM t_wait w JOIN t_run r ON( r.locktype IS NOT DISTINCT FROM w.locktype AND r. DATABASE IS NOT DISTINCT FROM w. DATABASE AND r.relation IS NOT DISTINCT FROM w.relation AND r.page IS NOT DISTINCT FROM w.page AND r.tuple IS NOT DISTINCT FROM w.tuple AND r.virtualxid IS NOT DISTINCT FROM w.virtualxid AND r.transactionid IS NOT DISTINCT FROM w.transactionid AND r.classid IS NOT DISTINCT FROM w.classid AND r.objid IS NOT DISTINCT FROM w.objid AND r.objsubid IS NOT DISTINCT FROM w.objsubid AND r.pid <> w.pid)), t_unionall AS( SELECT r.* FROM t_overlap r UNION ALL SELECT w.* FROM t_wait w) SELECT locktype, datname, relation :: regclass, page, tuple, virtualxid, transactionid :: TEXT, classid :: regclass, objid, objsubid, string_agg( 'Pid: ' || CASE WHEN pid IS NULL THEN 'NULL' ELSE pid :: TEXT END || chr(10) || 'Lock_Granted: ' || CASE WHEN GRANTED IS NULL THEN 'NULL' ELSE GRANTED :: TEXT END || ' , Mode: ' || CASE WHEN MODE IS NULL THEN 'NULL' ELSE MODE :: TEXT END || ' , FastPath: ' || CASE WHEN fastpath IS NULL THEN 'NULL' ELSE fastpath :: TEXT END || ' , VirtualTransaction: ' || CASE WHEN virtualtransaction IS NULL THEN 'NULL' ELSE virtualtransaction :: TEXT END || ' , Session_State: ' || CASE WHEN STATE IS NULL THEN 'NULL' ELSE STATE :: TEXT END || chr(10) || 'Username: ' || CASE WHEN usename IS NULL THEN 'NULL' ELSE usename :: TEXT END || ' , Database: ' || CASE WHEN datname IS NULL THEN 'NULL' ELSE datname :: TEXT END || ' , Client_Addr: ' || CASE WHEN client_addr IS NULL THEN 'NULL' ELSE client_addr :: TEXT END || ' , Client_Port: ' || CASE WHEN client_port IS NULL THEN 'NULL' ELSE client_port :: TEXT END || ' , Application_Name: ' || CASE WHEN application_name IS NULL THEN 'NULL' ELSE application_name :: TEXT END || chr(10) || 'Xact_Start: ' || CASE WHEN xact_start IS NULL THEN 'NULL' ELSE xact_start :: TEXT END || ' , Query_Start: ' || CASE WHEN query_start IS NULL THEN 'NULL' ELSE query_start :: TEXT END || ' , Xact_Elapse: ' || CASE WHEN(now() - xact_start) IS NULL THEN 'NULL' ELSE (now() - xact_start) :: TEXT END || ' , Query_Elapse: ' || CASE WHEN(now() - query_start) IS NULL THEN 'NULL' ELSE (now() - query_start) :: TEXT END || chr(10) || 'SQL (Current SQL in Transaction): ' || chr(10) || CASE WHEN query IS NULL THEN 'NULL' ELSE query :: TEXT END, chr(10) || '--------' || chr(10) ORDER BY ( CASE MODE WHEN 'INVALID' THEN 0 WHEN 'AccessShareLock' THEN 1 WHEN 'RowShareLock' THEN 2 WHEN 'RowExclusiveLock' THEN 3 WHEN 'ShareUpdateExclusiveLock' THEN 4 WHEN 'ShareLock' THEN 5 WHEN 'ShareRowExclusiveLock' THEN 6 WHEN 'ExclusiveLock' THEN 7 WHEN 'AccessExclusiveLock' THEN 8 ELSE 0 END) DESC, (CASE WHEN GRANTED THEN 0 ELSE 1 END)) AS lock_conflict FROM t_unionall GROUP BY locktype, datname, relation, page, tuple, virtualxid, transactionid :: TEXT, classid, objid, objsubid) T",
        "cycle":10},
        {"enable": 1, "query":"SELECT SUM(CASE WHEN wait_event_type is NULL THEN 1 ELSE 0 END) AS cpu_waits, SUM(CASE WHEN wait_event_type = 'LWLock' THEN 1 ELSE 0 END) AS lwlock_waits, SUM(CASE WHEN wait_event_type = 'Lock' THEN 1 ELSE 0 END) AS lock_waits, SUM(CASE WHEN wait_event_type = 'BufferPin' THEN 1 ELSE 0 END) AS bufferpin_waits, SUM(CASE WHEN wait_event_type = 'Activity' THEN 1 ELSE 0 END) AS activity_waits, SUM(CASE WHEN wait_event_type = 'Client' THEN 1 ELSE 0 END) AS client_waits, SUM(CASE WHEN wait_event_type = 'Extension' THEN 1 ELSE 0 END) AS extension_waits, SUM(CASE WHEN wait_event_type = 'IPC' THEN 1 ELSE 0 END) AS ipc_waits, SUM(CASE WHEN wait_event_type = 'Timeout' THEN 1 ELSE 0 END) AS timeout_waits, SUM(CASE WHEN wait_event_type = 'IO' THEN 1 ELSE 0 END) AS io_waits FROM pg_stat_activity WHERE usename NOT IN ('aurora', 'replicator') AND backend_type='client backend' AND state='active'",
         "min_version": 100000}
    ],
        "environment": "public_cloud",
        "enable_pfs": true,
        "local_disk_collect_interval": 15,
        "long_interval": 15,
        "extensions": ["polar_monitor"],
        "timeout_threshold_ms": 100
    }
}
